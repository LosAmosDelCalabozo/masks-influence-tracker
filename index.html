<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control de Influencia - Masks RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* General styling */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            position: relative;
            overflow-x: auto;
            font-weight: bold; /* All fonts bold */
        }

        /* Background effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Main container for content */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        /* Main title styling */
        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
        }

        /* Keyframe animation for title gradient */
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Section styling (tables) */
        .section {
            margin-bottom: 50px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 45px rgba(0, 0, 0, 0.4);
        }

        /* Section title styling */
        .section-title {
            text-align: center;
            font-size: 1.6em;
            font-weight: 700;
            margin-bottom: 25px;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            letter-spacing: 1px;
        }

        .section-title.give {
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        .section-title.receive {
            color: #4ecdc4;
            text-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        /* Table container styling */
        .table-container {
            overflow-x: auto;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
            min-width: 700px;
        }

        /* Table header styling */
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 15px 10px;
            text-align: center;
            font-size: 0.9em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        /* Specific styles for editable headers */
        th[contenteditable="true"] {
            cursor: text;
            background: rgba(255, 255, 255, 0.05); /* Subtle transparent background for editable headers */
            border-radius: 5px;
        }

        th[contenteditable="true"]:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        th[contenteditable="true"]:focus {
            outline: none;
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            border: 1px solid #00ffff;
        }
		
		thead th[contenteditable="true"] {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
		
        th:first-child {
            border-top-left-radius: 10px;
            width: 60px;
        }

        th:last-child {
            border-top-right-radius: 10px;
            width: 120px;
        }

        /* Table data cell styling */
        td {
            padding: 12px 10px;
            text-align: center;
            font-size: 0.85em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        tr:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: scale(1.01);
        }

        tr:hover td {
            color: #00ffff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
        }

        /* Styling for deleted rows */
        tr.deleted {
            background: rgba(255, 0, 0, 0.1) !important;
            opacity: 0.6;
            text-decoration: line-through;
        }

        tr.deleted:hover {
            background: rgba(255, 0, 0, 0.2) !important;
        }

        tr.deleted td {
            color: #ff6b6b !important;
        }

        /* Styling for editable data cells */
        td[contenteditable="true"] {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            transition: all 0.3s ease;
            cursor: text;
        }

        td[contenteditable="true"]:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        td[contenteditable="true"]:focus {
            outline: none;
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            border: 1px solid #00ffff;
        }

        /* Checkbox styling */
        .checkbox-cell {
            width: 60px;
        }

        .checkbox-cell input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #00ffff;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .checkbox-cell input[type="checkbox"]:hover {
            transform: scale(1.2);
        }

        .checkbox-cell input[type="checkbox"]:checked {
            filter: drop-shadow(0 0 5px #00ffff);
        }

        /* Action buttons in table cells */
        .actions-cell {
            width: 120px;
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
        }

        .action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.5px;
        }

        .delete-btn {
            background: linear-gradient(45deg, #ff4757, #ff3742);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 71, 87, 0.3);
        }

        .delete-btn:hover {
            background: linear-gradient(45deg, #ff3742, #ff2636);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 71, 87, 0.5);
        }

        .undo-btn {
            background: linear-gradient(45deg, #2ed573, #1dd361);
            color: white;
            box-shadow: 0 2px 8px rgba(46, 213, 115, 0.3);
        }

        .undo-btn:hover {
            background: linear-gradient(45deg, #1dd361, #17c653);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(46, 213, 115, 0.5);
        }

        /* Add row button */
        .add-button {
            display: block;
            width: 200px;
            margin: 20px auto 0;
            padding: 12px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: #fff;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .add-button:hover {
            background: linear-gradient(45deg, #764ba2, #667eea);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        /* Lookup/Preset section */
        .lookup-section {
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .lookup-title {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 20px;
            color: #ffff00;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
            letter-spacing: 1px;
        }

        .lookup-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .lookup-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            min-width: 100px;
        }

        /* Specific lookup button styles */
        .blank-btn {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            box-shadow: 0 3px 10px rgba(108, 117, 125, 0.3);
        }

        .blank-btn:hover {
            background: linear-gradient(45deg, #495057, #343a40);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(108, 117, 125, 0.5);
        }

        .henshin-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .henshin-btn:hover {
            background: linear-gradient(45deg, #764ba2, #667eea);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .random-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            box-shadow: 0 3px 10px rgba(255, 107, 107, 0.3);
        }

        .random-btn:hover {
            background: linear-gradient(45deg, #ee5a24, #ff6b6b);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }

        .clear-btn {
            background: linear-gradient(45deg, #ff4757, #ff6b6b);
            color: white;
            box-shadow: 0 3px 10px rgba(255, 71, 87, 0.3);
        }

        .clear-btn:hover {
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }

        /* NEW: Export and Import button styles */
        .export-btn {
            background: linear-gradient(45deg, #00b894, #008f7a);
            color: white;
            box-shadow: 0 3px 10px rgba(0, 184, 148, 0.3);
        }

        .export-btn:hover {
            background: linear-gradient(45deg, #008f7a, #00b894);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.5);
        }

        .import-btn {
            background: linear-gradient(45deg, #a29bfe, #6c5ce7);
            color: white;
            box-shadow: 0 3px 10px rgba(162, 155, 254, 0.3);
        }

        .import-btn:hover {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(162, 155, 254, 0.5);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body { padding: 15px; }
            h1 { font-size: 2em; margin-bottom: 30px; }
            .section { padding: 20px 15px; margin-bottom: 30px; }
            .section-title { font-size: 1.3em; margin-bottom: 20px; }
            th, td { padding: 10px 8px; font-size: 0.8em; }
            .add-button { width: 100%; max-width: 250px; }
            .actions-cell { flex-direction: column; gap: 3px; }
            .action-btn { font-size: 0.6em; padding: 4px 8px; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.6em; }
            .section-title { font-size: 1.1em; }
            th, td { padding: 8px 6px; font-size: 0.75em; }
            .lookup-buttons { flex-direction: column; align-items: center; }
            .lookup-btn { width: 120px; }
        }
		
		/* Print-specific styles */
        @media print {
            @page {
                size: A4 landscape;
                margin: 1cm;
            }

            body {
                background: white !important;
                color: black !important;
                padding: 0 !important;
                margin: 0 !important;
                height: 100%;
                font-weight: normal; /* Override bold for print if not desired */
            }

            .container {
                max-width: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
                height: 100%;
            }

            h1, .lookup-section, .add-button {
                display: none !important;
            }

            .section {
                background: transparent !important;
                box-shadow: none !important;
                border: none !important;
                margin: 0 !important;
                padding: 0 !important;
                page-break-inside: avoid;
                height: 100%;
            }

            .section-title {
                color: black !important;
                text-shadow: none !important;
                font-size: 16pt !important;
                margin-bottom: 10px !important;
            }

            .table-container {
                box-shadow: none !important;
                background: transparent !important;
                overflow: visible !important;
                height: calc(100% - 30px);
            }

            table {
                min-width: auto !important;
                width: 100% !important;
                font-size: 12pt !important;
                height: 100%;
            }

            th, td {
                padding: 8px 6px !important;
                font-size: 11pt !important;
                color: black !important;
                border: 1px solid #ddd !important;
            }

            th {
                background: #f2f2f2 !important;
                color: black !important;
            }
            
            th[contenteditable="true"] {
                background: #f2f2f2 !important; /* Keep consistent with other th */
                box-shadow: none !important;
                border: 1px solid #ddd !important; /* Add border for print */
            }

            tr:nth-child(even) {
                background: #f9f9f9 !important;
            }

            tr.deleted, tr.deleted td {
                text-decoration: line-through;
                color: #999 !important;
                background: #f9f9f9 !important;
            }

            .checkbox-cell input[type="checkbox"] {
                width: 16px !important;
                height: 16px !important;
                accent-color: black !important;
            }

            /* Side-by-side tables for printing */
            .print-layout {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                width: 100%;
                height: 100%;
            }

            .print-table {
                flex: 1 1 45%;
                min-width: 0;
                height: 100%;
            }

            .no-print {
                display: none !important;
            }

            /* Blank rows for printing */
            .blank-row {
                height: 30px; /* Adjust as needed for row height */
            }

            .blank-row td {
                border: 1px dashed #999 !important; /* Better border for blank rows */
                /* Ensure cells are empty but visible for blank rows */
                background-color: white !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Control de Influencia - Masks RPG ‚ö°</h1>
        
        <div class="print-layout">
            <div class="section print-table">
                <div class="section-title give">üî• Tengo Influencia Sobre</div>
                <div class="table-container">
                    <table id="giveTable">
                        <thead>
                            <tr>
                                <th>‚úîÔ∏è</th>
                                <th>Nombre</th>
                                <th id="giveRangerHeader" contenteditable="true" oninput="updateHeader(this, 'giveRanger')">Ranger</th>
                                <th>Raz√≥n</th>
                                <th>Fecha</th>
                                <th class="no-print">Acciones</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                <button class="add-button no-print" onclick="addRow('giveTable')">+ Agregar Personaje</button>
            </div>

            <div class="section print-table">
                <div class="section-title receive">‚ö° Tiene Influencia Sobre M√≠</div>
                <div class="table-container">
                    <table id="receiveTable">
                        <thead>
                            <tr>
                                <th>‚úîÔ∏è</th>
                                <th>Nombre</th>
                                <th id="receiveRangerHeader" contenteditable="true" oninput="updateHeader(this, 'receiveRanger')">Ranger</th>
                                <th>C√≥mo la Consigui√≥</th>
                                <th>Fecha</th>
                                <th class="no-print">Acciones</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                <button class="add-button no-print" onclick="addRow('receiveTable')">+ Agregar Personaje</button>
            </div>
        </div>

        <div class="lookup-section no-print">
            <div class="lookup-title">üîç Cargar Datos</div>
            <div class="lookup-buttons">
                <button class="lookup-btn blank-btn" onclick="loadPreset(event, 'blank')">Blank</button>
                <button class="lookup-btn henshin-btn" onclick="loadPreset(event, 'henshin')">Henshin</button>
                <button class="lookup-btn random-btn" onclick="loadPreset(event, 'random')">Random</button>
                <button class="lookup-btn clear-btn" onclick="clearAllData(event)">Borrar Todo</button>
                <button class="lookup-btn export-btn" onclick="exportDataToJson(event)">Descargar Datos</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importDataFromJson(event)">
                <button class="lookup-btn import-btn" onclick="document.getElementById('importFile').click()">Cargar Datos</button>
            </div>
        </div>
        <button class="add-button print-btn no-print" onclick="prepareForPrinting()">üñ®Ô∏è Imprimir</button>
    </div>

    <script>
        // In-memory storage for game data
        let gameData = {
            giveTable: [],
            receiveTable: []
        };
        // Store a copy of original gameData for printing to revert later
        let originalGameData = {};

        // Save data to localStorage
        function saveGameData() {
            localStorage.setItem('masksInfluenceTracker', JSON.stringify(gameData));
        }

        // Load data from localStorage
        function loadGameData() {
            const savedData = localStorage.getItem('masksInfluenceTracker');
            if (savedData) {
                gameData = JSON.parse(savedData);
                return true;
            }
            return false;
        }

        // Save header text to localStorage
        function updateHeader(element, headerKey) {
            localStorage.setItem(`masksInfluenceTracker_header_${headerKey}`, element.textContent);
        }

        // Load header text from localStorage
        function loadHeaders() {
            const giveRangerHeader = localStorage.getItem('masksInfluenceTracker_header_giveRanger');
            const receiveRangerHeader = localStorage.getItem('masksInfluenceTracker_header_receiveRanger');

            if (giveRangerHeader) {
                document.getElementById('giveRangerHeader').textContent = giveRangerHeader;
            } else {
                document.getElementById('giveRangerHeader').textContent = 'Ranger';
            }

            if (receiveRangerHeader) {
                document.getElementById('receiveRangerHeader').textContent = receiveRangerHeader;
            } else {
                document.getElementById('receiveRangerHeader').textContent = 'Ranger';
            }
        }

        // Clear all data
        function clearAllData(event) { // Added event parameter
            // Using a custom confirmation message in the UI instead of window.confirm
            const confirmClear = confirm("¬øEst√°s seguro de que quieres borrar todos los datos? Esta acci√≥n no se puede deshacer.");
            if (confirmClear) {
                localStorage.removeItem('masksInfluenceTracker');
                localStorage.removeItem('masksInfluenceTracker_header_giveRanger'); // Clear saved header for give table
                localStorage.removeItem('masksInfluenceTracker_header_receiveRanger'); // Clear saved header for receive table
                gameData = { giveTable: [], receiveTable: [] };
                populateTablesFromData();
                loadHeaders(); // Reset headers to default as well
                
                // Visual feedback
                const button = event.target;
                const originalText = button.textContent;
                const originalClass = button.className;
                
                button.textContent = '‚úì Borrado';
                button.className = 'lookup-btn clear-btn';
                button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.className = originalClass;
                    button.style.background = '';
                }, 1500);
            }
        }

        // Populate tables from gameData, filtering out deleted rows
        function populateTablesFromData() {
            // Clear existing tables
            document.getElementById('giveTable').querySelector('tbody').innerHTML = '';
            document.getElementById('receiveTable').querySelector('tbody').innerHTML = '';

            // Populate giveTable
            gameData.giveTable.forEach(rowData => {
                // Only render if not deleted OR if it's a temporary blank row (for printing)
                if (!rowData.deleted || rowData.tempBlank) {
                    const row = createRow(
                        rowData.name,
                        rowData.ranger,
                        rowData.reason,
                        rowData.date,
                        rowData.checked,
                        rowData.deleted, 
                        'giveTable',
                        rowData.tempBlank
                    );
                    document.getElementById('giveTable').querySelector('tbody').appendChild(row);
                }
            });

            // Populate receiveTable
            gameData.receiveTable.forEach(rowData => {
                // Only render if not deleted OR if it's a temporary blank row (for printing)
                if (!rowData.deleted || rowData.tempBlank) {
                    const row = createRow(
                        rowData.name,
                        rowData.ranger,
                        rowData.reason,
                        rowData.date,
                        rowData.checked,
                        rowData.deleted, 
                        'receiveTable',
                        rowData.tempBlank
                    );
                    document.getElementById('receiveTable').querySelector('tbody').appendChild(row);
                }
            });
        }
        
        // This function now adds "data" for blank rows into gameData temporarily
        function addBlankRowsForPrinting() {
            const targetRows = 15; // Approximately 15 rows fit on A4 landscape
            
            // Add blank data rows to give table
            const currentGiveDataRows = gameData.giveTable.filter(row => !row.deleted).length;
            for (let i = currentGiveDataRows; i < targetRows; i++) {
                gameData.giveTable.push({
                    checked: false, name: "", ranger: "", reason: "", date: "", deleted: false, tempBlank: true
                });
            }
            
            // Add blank data rows to receive table
            const currentReceiveDataRows = gameData.receiveTable.filter(row => !row.deleted).length;
            for (let i = currentReceiveDataRows; i < targetRows; i++) {
                gameData.receiveTable.push({
                    checked: false, name: "", ranger: "", reason: "", date: "", deleted: false, tempBlank: true
                });
            }
        }

        function prepareForPrinting() {
            // Store the current state of gameData
            originalGameData = JSON.parse(JSON.stringify(gameData)); 

            addBlankRowsForPrinting(); // Add blank rows to gameData
            populateTablesFromData(); // Re-render tables with blank rows

            window.print();
            
            // Revert gameData and re-populate after printing is done (or canceled)
            // Use setTimeout to allow the print dialog to be handled first
            setTimeout(() => {
                gameData = JSON.parse(JSON.stringify(originalGameData)); // Restore original data
                populateTablesFromData(); // Re-render tables without blank rows
            }, 500); // Give a little time for print dialog to appear/close
        }

        // Default data sets
        const defaultDataSets = {
            henshin: {
                giveTable: [
                    { checked: false, name: "Rajish", ranger: "Caracol Zafiro", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Kenshiro", ranger: "Le√≥n Dorado", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Ethan", ranger: "Guepardo Jade", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Pa Pua", ranger: "Erizo √ìnix", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Yoko", ranger: "Drag√≥n Rub√≠", reason: "l√≠der", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Gandix Prime", ranger: "‚Äî", reason: "mentor", date: "", deleted: false, tempBlank: false }
                ],
                receiveTable: [
                    { checked: false, name: "Rajish", ranger: "Caracol Zafiro", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Kenshiro", ranger: "Le√≥n Dorado", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Ethan", ranger: "Guepardo Jade", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Pa Pua", ranger: "Erizo √ìnix", reason: "", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Yoko", ranger: "Drag√≥n Rub√≠", reason: "l√≠der", date: "", deleted: false, tempBlank: false },
                    { checked: false, name: "Gandix Prime", ranger: "‚Äî", reason: "mentor", date: "", deleted: false, tempBlank: false }
                ]
            },
            blank: {
                giveTable: [],
                receiveTable: []
            }
        };

        // Random data generators
        const randomNames = [
            "Alex Storm", "Maya Chen", "Jordan Rivers", "Sam Nova", "Riley Phoenix",
            "Casey Volt", "Quinn Shadow", "Avery Blaze", "Harper Frost", "Skyler Wave",
            "Dr. Marcus Vex", "Luna Darkmore", "Captain Steel", "Raven Nightshade", "Echo Prime",
            "Zara Lightning", "Kai Stormwind", "Nova Sterling", "Ash Blackthorne", "Vera Cosmos"
        ];

        const randomRangers = [
            "√Åguila Dorada", "Lobo Plateado", "Tigre Escarlata", "Halc√≥n Azul", "Serpiente Verde",
            "Oso Bronce", "Lib√©lula Violeta", "Escorpi√≥n Negro", "Mariposa Rosa", "Ciervo Blanco",
            "Drag√≥n Cristal", "F√©nix Carmes√≠", "Pantera Sombra", "Delf√≠n Turquesa", "B√∫ho Lunar",
            "Mantis Jade", "C√≥ndor Solar", "Zorro √Åmbar", "Ballena Marina", "Murci√©lago Obsidiana"
        ];

        const randomReasons = [
            "salv√© su vida en batalla", "descubr√≠ su identidad secreta", "le ense√±√© una t√©cnica especial",
            "proteg√≠ a su familia", "le revel√© informaci√≥n importante", "luch√© junto a √©l/ella",
            "le ayud√© en un momento dif√≠cil", "compartimos un secreto", "entren√© juntos",
            "le salv√© de una trampa", "conf√≠a en mi juicio", "le di consejos cruciales",
            "le ayud√≥ a controlar sus poderes", "le proteg√≠ de sus enemigos", "le mostr√© el camino correcto"
        ];

        const randomInfluenceGains = [
            "me salv√≥ la vida", "descubri√≥ mi punto d√©bil", "me derrot√≥ en combate",
            "me ense√±√≥ una lecci√≥n importante", "me ayud√≥ cuando m√°s lo necesitaba", "conf√≠o en su experiencia",
            "me inspir√≥ a ser mejor", "me protegi√≥ de un gran peligro", "me mostr√≥ mi error",
            "gan√≥ mi respeto en batalla", "me ayud√≥ con mis poderes", "me dio esperanza",
            "me defendi√≥ ante otros", "sacrific√≥ algo por m√≠", "me ense√±√≥ sobre el hero√≠smo"
        ];

        function generateRandomData() {
            const shuffleArray = (array) => {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            };

            const getRandomDate = () => {
                const months = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", 
                               "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
                const month = months[Math.floor(Math.random() * months.length)];
                const day = Math.floor(Math.random() * 28) + 1;
                return `${day} ${month}`;
            };

            const numEntries = Math.floor(Math.random() * 6) + 4; // 4-9 entries
            const shuffledNames = shuffleArray(randomNames);
            const shuffledRangers = shuffleArray(randomRangers);

            const giveTable = [];
            const receiveTable = [];

            for (let i = 0; i < numEntries && i < shuffledNames.length; i++) {
                const name = shuffledNames[i];
                const ranger = shuffledRangers[i];
                const date = getRandomDate();

                // Some entries appear in both tables, some only in one
                const inBoth = Math.random() < 0.6; // 60% chance to be in both
                const inGive = inBoth || Math.random() < 0.7; // 70% chance if not in both
                const inReceive = inBoth || !inGive || Math.random() < 0.7;

                if (inGive) {
                    const reason = randomReasons[Math.floor(Math.random() * randomReasons.length)];
                    giveTable.push({
                        checked: false,
                        name: name,
                        ranger: ranger,
                        reason: reason,
                        date: date,
                        deleted: false,
                        tempBlank: false
                    });
                }

                if (inReceive) {
                    const howGained = randomInfluenceGains[Math.floor(Math.random() * randomInfluenceGains.length)];
                    receiveTable.push({
                        checked: false,
                        name: name,
                        ranger: ranger,
                        reason: howGained,
                        date: date,
                        deleted: false,
                        tempBlank: false
                    });
                }
            }

            return { giveTable, receiveTable };
        }

        function loadPreset(event, preset) { // Added event parameter
            let data;
            
            if (preset === 'random') {
                data = generateRandomData();
            } else {
                data = defaultDataSets[preset];
            }

            // Update gameData
            gameData = {
                giveTable: [...data.giveTable],
                receiveTable: [...data.receiveTable]
            };
            
            // Save and populate tables
            saveGameData();
            populateTablesFromData();

            // Visual feedback
            const button = event.target;
            const originalText = button.textContent;
            const originalClass = button.className;
            
            button.textContent = '‚úì Cargado';
            button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.className = originalClass;
                button.style.background = '';
            }, 1500);
        }

        function createRow(name = "", ranger = "", reason = "", date = "", checked = false, deleted = false, tableId = "", tempBlank = false) {
            const tr = document.createElement("tr");
            if (deleted) {
                tr.classList.add("deleted"); // Apply deleted style if marked
            }
            if (tempBlank) {
                tr.classList.add("blank-row"); // Apply blank row style for printing
            }
            
            tr.innerHTML = `
                <td class="checkbox-cell">
                    ${tempBlank ? `<input type="checkbox" disabled>` : `<input type="checkbox" ${checked ? "checked" : ""} onchange="updateRowData(this)">`}
                </td>
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${name || '&nbsp;'}</td>
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${ranger || '&nbsp;'}</td>
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${reason || '&nbsp;'}</td>
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${date || '&nbsp;'}</td>
                <td class="actions-cell no-print">
                    ${tempBlank ? '&nbsp;' : // No actions for blank rows
                        (deleted ? 
                            '<button class="action-btn undo-btn" onclick="undoDelete(this)">Restaurar</button>' :
                            '<button class="action-btn delete-btn" onclick="deleteRow(this)">Eliminar</button>'
                        )
                    }
                </td>
            `;
            
            return tr;
        }

        function addRow(tableId) {
            const newRowData = {
                checked: false,
                name: "",
                ranger: "",
                reason: "",
                date: "",
                deleted: false,
                tempBlank: false // New rows are not temporary blank
            };
            gameData[tableId].push(newRowData);
            saveGameData();
            populateTablesFromData(); // Re-populate to show the new row

            // Find the newly added row in the DOM and focus on its first editable cell
            const tableBody = document.getElementById(tableId).querySelector('tbody');
            const lastRow = tableBody.lastElementChild;
            if (lastRow) {
                const firstEditableCell = lastRow.querySelector('td[contenteditable="true"]');
                if (firstEditableCell) {
                    firstEditableCell.focus();
                }
            }
        }

        function deleteRow(button) {
            const row = button.closest('tr');
            const table = button.closest('table');
            const tableId = table.id;
            const rowIndexInDOM = Array.from(table.querySelectorAll('tbody tr')).indexOf(row);
            
            // Find the corresponding data item in gameData (considering visible rows only for indexing)
            let dataIndex = -1;
            let visibleCount = 0;
            for (let i = 0; i < gameData[tableId].length; i++) {
                // If the row is not deleted and not a temporary blank row, it's visible in normal view
                if (!gameData[tableId][i].deleted && !gameData[tableId][i].tempBlank) {
                    if (visibleCount === rowIndexInDOM) {
                        dataIndex = i;
                        break;
                    }
                    visibleCount++;
                }
            }

            if (dataIndex !== -1) {
                gameData[tableId][dataIndex].deleted = true; // Mark as deleted in gameData
                saveGameData(); // Save the updated data

                // Immediately update UI to show it's marked for deletion, but don't remove
                row.classList.add('deleted');
                button.textContent = 'Restaurar';
                button.className = 'action-btn undo-btn';
                // Update the onclick to point to undoDelete
                button.onclick = () => undoDelete(button); 
            }
        }

        function undoDelete(button) {
            const row = button.closest('tr');
            const table = button.closest('table');
            const tableId = table.id;
            // The name is used to find the corresponding data item in gameData, as rowIndexInDOM might not be reliable after filtering
            const nameToFind = row.querySelector('td:nth-child(2)').textContent; 
            
            // Find the row in gameData that matches the name and is currently marked as deleted
            // Ensure we are looking for the exact row in gameData, not just any row with that name
            const dataRowIndex = gameData[tableId].findIndex(item => item.name === nameToFind && item.deleted);
            
            if (dataRowIndex !== -1) {
                gameData[tableId][dataRowIndex].deleted = false; // Mark as not deleted
                saveGameData(); // Save updated data
                
                // Immediately update UI to show it's restored
                row.classList.remove('deleted');
                button.textContent = 'Eliminar';
                button.className = 'action-btn delete-btn';
                // Update the onclick to point back to deleteRow
                button.onclick = () => deleteRow(button);
            }
        }

        function updateRowData(element) {
            const row = element.closest('tr');
            const table = element.closest('table');
            const tableId = table.id;
            const rowIndexInDOM = Array.from(table.querySelectorAll('tbody tr')).indexOf(row);
            
            // Find the corresponding data item in gameData based on its current visible position
            let dataIndex = -1;
            let visibleCount = 0;
            for (let i = 0; i < gameData[tableId].length; i++) {
                // Only consider non-deleted and non-temporary blank rows for visible indexing
                if (!gameData[tableId][i].deleted && !gameData[tableId][i].tempBlank) {
                    if (visibleCount === rowIndexInDOM) {
                        dataIndex = i;
                        break;
                    }
                    visibleCount++;
                }
            }
            
            if (dataIndex !== -1 && gameData[tableId][dataIndex]) {
                const cells = row.querySelectorAll('td');
                const checkbox = cells[0].querySelector('input[type="checkbox"]');
                
                gameData[tableId][dataIndex] = {
                    ...gameData[tableId][dataIndex], // Keep existing properties like 'deleted', 'tempBlank'
                    checked: checkbox ? checkbox.checked : false,
                    name: cells[1].textContent,
                    ranger: cells[2].textContent,
                    reason: cells[3].textContent,
                    date: cells[4].textContent
                };
                
                saveGameData(); // Save data
            }
        }

        /**
         * Exports the current game data and header information to a JSON file,
         * triggering a download for the user.
         * @param {Event} event The click event from the button.
         */
        function exportDataToJson(event) {
            const dataToSave = {
                gameData: gameData,
                headers: {
                    giveRanger: document.getElementById('giveRangerHeader').textContent,
                    receiveRanger: document.getElementById('receiveRangerHeader').textContent
                }
            };
            const jsonData = JSON.stringify(dataToSave, null, 2); // Pretty print JSON for readability
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'masks_influence_tracker_data.json'; // Default filename
            document.body.appendChild(a);
            a.click(); // Programmatically click the link to trigger download
            document.body.removeChild(a); // Clean up the temporary link
            URL.revokeObjectURL(url); // Release the object URL

            // Visual feedback for the button
            const button = event.target;
            const originalText = button.textContent;
            const originalClass = button.className;
            
            button.textContent = '‚úì Descargado';
            button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)'; // Green for success
            
            setTimeout(() => {
                button.textContent = originalText;
                button.className = originalClass;
                button.style.background = ''; // Revert background
            }, 1500); // Revert after 1.5 seconds
        }

        /**
         * Imports game data and header information from a selected JSON file.
         * @param {Event} event The change event from the file input.
         */
        function importDataFromJson(event) {
            const file = event.target.files[0];
            const button = document.querySelector('.import-btn'); // Get the import button for feedback
            const originalText = button.textContent;
            const originalClass = button.className;

            if (!file) {
                // No file selected, reset button feedback if it was previously showing an error
                button.textContent = originalText;
                button.className = originalClass;
                button.style.background = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    // Validate the structure of the imported data
                    if (importedData.gameData && importedData.headers && 
                        importedData.gameData.giveTable && importedData.gameData.receiveTable &&
                        importedData.headers.giveRanger !== undefined && importedData.headers.receiveRanger !== undefined) {
                        
                        gameData = importedData.gameData; // Update global gameData
                        
                        // Restore headers to localStorage
                        localStorage.setItem('masksInfluenceTracker_header_giveRanger', importedData.headers.giveRanger);
                        localStorage.setItem('masksInfluenceTracker_header_receiveRanger', importedData.headers.receiveRanger);
                        
                        saveGameData(); // Save the newly imported data to localStorage
                        populateTablesFromData(); // Refresh tables with new data
                        loadHeaders(); // Refresh headers with new data

                        // Visual feedback for success
                        button.textContent = '‚úì Cargado';
                        button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)'; // Green for success
                        
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.className = originalClass;
                            button.style.background = '';
                        }, 1500);

                    } else {
                        // Invalid file format
                        console.error("Error: El archivo JSON no tiene el formato esperado.");
                        button.textContent = '‚ùå Error';
                        button.style.background = 'linear-gradient(45deg, #ff4757, #ff3742)'; // Red for error
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.className = originalClass;
                            button.style.background = '';
                        }, 2500);
                    }
                } catch (error) {
                    // JSON parsing error
                    console.error("Error al leer el archivo JSON: ", error);
                    button.textContent = '‚ùå Error JSON';
                    button.style.background = 'linear-gradient(45deg, #ff4757, #ff3742)'; // Red for error
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.className = originalClass;
                        button.style.background = '';
                    }, 2500);
                }
            };
            reader.readAsText(file); // Read the file content as text
            // Clear the input so the same file can be re-selected if needed
            event.target.value = '';
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            // Try to load saved data first
            if (!loadGameData()) {
                // If no saved data, load the Henshin preset
                loadPreset(null, 'henshin'); // Pass null for event as it's not a user click
            } else {
                // If loaded saved data, populate tables
                populateTablesFromData();
            }

            // Load saved headers
            loadHeaders();

            // Update print button
            const printBtn = document.querySelector('.print-btn');
            if (printBtn) {
                printBtn.onclick = prepareForPrinting;
            }
        });
    </script>
</body>
</html>
