<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control de Influencia - Masks RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* General styling */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            position: relative;
            overflow-x: auto;
            font-weight: bold; /* All fonts bold */
        }

        /* Background effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Main container for content */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        /* Main title styling */
        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
        }

        /* Keyframe animation for title gradient */
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Section styling (tables) */
        .section {
            margin-bottom: 50px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 45px rgba(0, 0, 0, 0.4);
        }

        /* Section title styling */
        .section-title {
            text-align: center;
            font-size: 1.6em;
            font-weight: 700;
            margin-bottom: 25px;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            letter-spacing: 1px;
        }

        .section-title.give {
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        .section-title.receive {
            color: #4ecdc4;
            text-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        /* Table container styling */
        .table-container {
            overflow-x: auto;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
            min-width: 700px;
        }

        /* Table header styling */
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 15px 10px;
            text-align: center;
            font-size: 0.9em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            position: relative; /* For sort icons */
        }
        
        /* Specific styles for editable headers */
        th[contenteditable="true"] {
            cursor: text;
            background: rgba(255, 255, 255, 0.05); /* Subtle transparent background for editable headers */
            border-radius: 5px;
        }

        th[contenteditable="true"]:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        th[contenteditable="true"]:focus {
            outline: none;
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            border: 1px solid #00ffff;
        }
		
		thead th[contenteditable="true"] {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
		
        th:first-child {
            border-top-left-radius: 10px;
            width: 60px;
        }

        th:last-child {
            border-top-right-radius: 10px;
            width: 120px;
        }

        /* Sortable header styles */
        th.sortable {
            cursor: pointer;
            padding-right: 30px; /* Make space for the icon */
        }

        th.sortable .sort-icon {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.6);
            transition: color 0.2s ease;
        }

        th.sortable:hover .sort-icon {
            color: #fff;
        }

        th.sortable.asc .sort-icon::after {
            content: '‚ñ≤'; /* Up arrow for ascending */
        }

        th.sortable.desc .sort-icon::after {
            content: '‚ñº'; /* Down arrow for descending */
        }

        /* Table data cell styling */
        td {
            padding: 12px 10px;
            text-align: center;
            font-size: 0.85em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        tr:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: scale(1.01);
        }

        tr:hover td {
            color: #00ffff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
        }

        /* Styling for deleted rows */
        tr.deleted {
            background: rgba(255, 0, 0, 0.1) !important;
            opacity: 0.6;
            text-decoration: line-through;
        }

        tr.deleted:hover {
            background: rgba(255, 0, 0, 0.2) !important;
        }

        tr.deleted td {
            color: #ff6b6b !important;
        }

        /* Styling for editable data cells */
        td[contenteditable="true"] {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            transition: all 0.3s ease;
            cursor: text;
        }

        td[contenteditable="true"]:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        td[contenteditable="true"]:focus {
            outline: none;
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            border: 1px solid #00ffff;
        }

        /* Checkbox styling */
        .checkbox-cell {
            width: 60px;
        }

        .checkbox-cell input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #00ffff;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .checkbox-cell input[type="checkbox"]:hover {
            transform: scale(1.2);
        }

        .checkbox-cell input[type="checkbox"]:checked {
            filter: drop-shadow(0 0 5px #00ffff);
        }

        /* Action buttons in table cells */
        .actions-cell {
            width: 120px;
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
        }

        .action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.5px;
        }

        .delete-btn {
            background: linear-gradient(45deg, #ff4757, #ff3742);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 71, 87, 0.3);
        }

        .delete-btn:hover {
            background: linear-gradient(45deg, #ff3742, #ff2636);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 71, 87, 0.5);
        }

        .undo-btn {
            background: linear-gradient(45deg, #2ed573, #1dd361);
            color: white;
            box-shadow: 0 2px 8px rgba(46, 213, 115, 0.3);
        }

        .undo-btn:hover {
            background: linear-gradient(45deg, #1dd361, #17c653);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(46, 213, 115, 0.5);
        }

        /* Add row button */
        .add-button {
            display: block;
            width: 200px;
            margin: 20px auto 0;
            padding: 12px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: #fff;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .add-button:hover {
            background: linear-gradient(45deg, #764ba2, #667eea);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        /* Lookup/Preset section */
        .lookup-section {
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .lookup-title {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 20px;
            color: #ffff00;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
            letter-spacing: 1px;
        }

        .lookup-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .lookup-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            min-width: 100px;
        }

        /* Specific lookup button styles */
        .blank-btn {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            box-shadow: 0 3px 10px rgba(108, 117, 125, 0.3);
        }

        .blank-btn:hover {
            background: linear-gradient(45deg, #495057, #343a40);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(108, 117, 125, 0.5);
        }

        .random-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            box-shadow: 0 3px 10px rgba(255, 107, 107, 0.3);
        }

        .random-btn:hover {
            background: linear-gradient(45deg, #ee5a24, #ff6b6b);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }

        .clear-btn {
            background: linear-gradient(45deg, #ff4757, #ff6b6b);
            color: white;
            box-shadow: 0 3px 10px rgba(255, 71, 87, 0.3);
        }

        .clear-btn:hover {
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }

        /* NEW: Export and Import button styles */
        .export-btn {
            background: linear-gradient(45deg, #00b894, #008f7a);
            color: white;
            box-shadow: 0 3px 10px rgba(0, 184, 148, 0.3);
        }

        .export-btn:hover {
            background: linear-gradient(45deg, #008f7a, #00b894);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.5);
        }

        .import-btn {
            background: linear-gradient(45deg, #a29bfe, #6c5ce7);
            color: white;
            box-shadow: 0 3px 10px rgba(162, 155, 254, 0.3);
        }

        .import-btn:hover {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(162, 155, 254, 0.5);
        }

        /* Language Toggle */
        .language-toggle {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .lang-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.5px;
            background: linear-gradient(45deg, #34495e, #2c3e50);
            color: #fff;
            margin: 0 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .lang-btn.active {
            background: linear-gradient(45deg, #00ffff, #00b894);
            box-shadow: 0 4px 10px rgba(0, 255, 255, 0.4);
            transform: translateY(-1px);
        }

        .lang-btn:hover:not(.active) {
            background: linear-gradient(45deg, #4a69bd, #3b5998);
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body { padding: 15px; }
            h1 { font-size: 2em; margin-bottom: 30px; }
            .section { padding: 20px 15px; margin-bottom: 30px; }
            .section-title { font-size: 1.3em; margin-bottom: 20px; }
            th, td { padding: 10px 8px; font-size: 0.8em; }
            .add-button { width: 100%; max-width: 250px; }
            .actions-cell { flex-direction: column; gap: 3px; }
            .action-btn { font-size: 0.6em; padding: 4px 8px; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.6em; }
            .section-title { font-size: 1.1em; }
            th, td { padding: 8px 6px; font-size: 0.75em; }
            .lookup-buttons { flex-direction: column; align-items: center; }
            .lookup-btn { width: 120px; }
        }
		
		/* Print-specific styles */
        @media print {
            @page {
                size: A4 landscape;
                margin: 1cm;
            }

            body {
                background: white !important;
                color: black !important;
                padding: 0 !important;
                margin: 0 !important;
                height: 100%;
                font-weight: normal; /* Override bold for print if not desired */
            }

            .container {
                max-width: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
                height: 100%;
            }

            h1, .lookup-section, .add-button, .language-toggle {
                display: none !important;
            }

            .section {
                background: transparent !important;
                box-shadow: none !important;
                border: none !important;
                margin: 0 !important;
                padding: 0 !important;
                page-break-inside: avoid;
                height: 100%;
            }

            .section-title {
                color: black !important;
                text-shadow: none !important;
                font-size: 16pt !important;
                margin-bottom: 10px !important;
            }

            .table-container {
                box-shadow: none !important;
                background: transparent !important;
                overflow: visible !important;
                height: calc(100% - 30px);
            }

            table {
                min-width: auto !important;
                width: 100% !important;
                font-size: 12pt !important;
                height: 100%;
            }

            th, td {
                padding: 8px 6px !important;
                font-size: 11pt !important;
                color: black !important;
                border: 1px solid #ddd !important;
            }

            th {
                background: #f2f2f2 !important;
                color: black !important;
            }
            
            th[contenteditable="true"] {
                background: #f2f2f2 !important; /* Keep consistent with other th */
                box-shadow: none !important;
                border: 1px solid #ddd !important; /* Add border for print */
            }

            tr:nth-child(even) {
                background: #f9f9f9 !important;
            }

            tr.deleted, tr.deleted td {
                text-decoration: line-through;
                color: #999 !important;
                background: #f9f9f9 !important;
            }

            .checkbox-cell input[type="checkbox"] {
                width: 16px !important;
                height: 16px !important;
                accent-color: black !important;
            }

            /* Side-by-side tables for printing */
            .print-layout {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                width: 100%;
                height: 100%;
            }

            .print-table {
                flex: 1 1 45%;
                min-width: 0;
                height: 100%;
            }

            .no-print {
                display: none !important;
            }

            /* Blank rows for printing */
            .blank-row {
                height: 30px; /* Adjust as needed for row height */
            }

            .blank-row td {
                border: 1px dashed #999 !important; /* Better border for blank rows */
                /* Ensure cells are empty but visible for blank rows */
                background-color: white !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 data-key="mainTitle">‚ö° Control de Influencia - Masks RPG ‚ö°</h1>
        
        <div class="language-toggle no-print">
            <button class="lang-btn" data-lang="en">English</button>
            <button class="lang-btn" data-lang="es">Espa√±ol</button>
        </div>

        <div class="print-layout">
            <div class="section print-table">
                <div class="section-title give" data-key="influenceOver">üî• Tengo Influencia Sobre</div>
                <div class="table-container">
                    <table id="giveTable">
                        <thead>
                            <tr>
                                <th data-key="checkboxHeader">‚úîÔ∏è</th>
                                <th class="sortable" data-column="name" data-key="nameHeader">Nombre <span class="sort-icon"></span></th>
                                <th id="givePowerHeader" contenteditable="true" oninput="updateHeader(this, 'givePower')" class="sortable" data-column="power" data-key="powerHeader">Poder <span class="sort-icon"></span></th>
                                <th class="sortable" data-column="reason" data-key="reasonHeader">Raz√≥n <span class="sort-icon"></span></th>
                                <th class="sortable" data-column="date" data-key="dateHeader">Fecha <span class="sort-icon"></span></th>
                                <th class="no-print" data-key="actionsHeader">Acciones</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                <button class="add-button no-print" onclick="addRow('giveTable')" data-key="addCharacterBtn">+ Agregar Personaje</button>
            </div>

            <div class="section print-table">
                <div class="section-title receive" data-key="influencedBy">‚ö° Tiene Influencia Sobre M√≠</div>
                <div class="table-container">
                    <table id="receiveTable">
                        <thead>
                            <tr>
                                <th data-key="checkboxHeader">‚úîÔ∏è</th>
                                <th class="sortable" data-column="name" data-key="nameHeader">Nombre <span class="sort-icon"></span></th>
                                <th id="receivePowerHeader" contenteditable="true" oninput="updateHeader(this, 'receivePower')" class="sortable" data-column="power" data-key="powerHeader">Poder <span class="sort-icon"></span></th>
                                <th class="sortable" data-column="reason" data-key="howGainedHeader">C√≥mo la Consigui√≥ <span class="sort-icon"></span></th>
                                <th class="sortable" data-column="date" data-key="dateHeader">Fecha <span class="sort-icon"></span></th>
                                <th class="no-print" data-key="actionsHeader">Acciones</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                <button class="add-button no-print" onclick="addRow('receiveTable')" data-key="addCharacterBtn">+ Agregar Personaje</button>
            </div>
        </div>

        <div class="lookup-section no-print">
            <div class="lookup-title" data-key="loadDataTitle">üîç Cargar Datos</div>
            <div class="lookup-buttons">
                <button class="lookup-btn blank-btn" onclick="loadPreset(event, 'blank')" data-key="blankBtn">Blank</button>
                <button class="lookup-btn random-btn" onclick="loadPreset(event, 'random')" data-key="randomBtn">Random</button>
                <button class="lookup-btn export-btn" onclick="exportDataToJson(event)" data-key="downloadDataBtn">Descargar Datos</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importDataFromJson(event)">
                <button class="lookup-btn import-btn" onclick="document.getElementById('importFile').click()" data-key="loadDataBtn">Cargar Datos</button>
            </div>
        </div>
        <button class="add-button print-btn no-print" onclick="prepareForPrinting()" data-key="printBtn">üñ®Ô∏è Imprimir</button>
    </div>

    <script>
        // In-memory storage for game data
        let gameData = {
            giveTable: [],
            receiveTable: []
        };
        // Store a copy of original gameData for printing to revert later
        let originalGameData = {};

        // Track current sort state for each table
        let sortState = {
            giveTable: { column: null, direction: 'asc' },
            receiveTable: { column: null, direction: 'asc' }
        };

        // Current language state
        let currentLang = localStorage.getItem('masksInfluenceTracker_lang') || 'en'; // Default to English

        // Translation object
        const translations = {
            en: {
                mainTitle: '‚ö° Influence Tracker - Masks RPG ‚ö°',
                influenceOver: 'üî• I have Influence Over',
                influencedBy: "‚ö° I'm  Influenced By",
                checkboxHeader: '‚úîÔ∏è',
                nameHeader: 'Name',
                powerHeader: 'Power',
                reasonHeader: 'Reason',
                dateHeader: 'Date',
                howGainedHeader: 'How Gained',
                actionsHeader: 'Actions',
                addCharacterBtn: '+ Add Character',
                loadDataTitle: 'üîç Load Data',
                blankBtn: 'Blank',
                randomBtn: 'Random',
                downloadDataBtn: 'Download Data',
                loadDataBtn: 'Load Data',
                printBtn: 'üñ®Ô∏è Print',
                deleteBtn: 'Delete',
                restoreBtn: 'Restore',
                clearedMsg: '‚úì Cleared',
                loadedMsg: '‚úì Loaded',
                downloadedMsg: '‚úì Downloaded',
                errorMsg: '‚ùå Error',
                jsonErrorMsg: '‚ùå JSON Error',
                confirmClear: 'Are you sure you want to clear all data? This action cannot be undone.'
            },
            es: {
                mainTitle: '‚ö° Control de Influencia - Masks RPG ‚ö°',
                influenceOver: 'üî• Tengo Influencia Sobre',
                influencedBy: '‚ö° Tiene Influencia Sobre M√≠',
                checkboxHeader: '‚úîÔ∏è',
                nameHeader: 'Nombre',
                powerHeader: 'Poder',
                reasonHeader: 'Raz√≥n',
                dateHeader: 'Fecha',
                howGainedHeader: 'C√≥mo la Consigui√≥',
                actionsHeader: 'Acciones',
                addCharacterBtn: '+ Agregar Personaje',
                loadDataTitle: 'üîç Cargar Datos',
                blankBtn: 'Blank',
                randomBtn: 'Random',
                downloadDataBtn: 'Descargar Datos',
                loadDataBtn: 'Cargar Datos',
                printBtn: 'üñ®Ô∏è Imprimir',
                deleteBtn: 'Eliminar',
                restoreBtn: 'Restaurar',
                clearedMsg: '‚úì Borrado',
                loadedMsg: '‚úì Cargado',
                downloadedMsg: '‚úì Descargado',
                errorMsg: '‚ùå Error',
                jsonErrorMsg: '‚ùå Error JSON',
                confirmClear: '¬øEst√°s seguro de que quieres borrar todos los datos? Esta acci√≥n no se puede deshacer.'
            }
        };

        // Random data generators (English)
        const randomNames_en = [
            "Alex Storm", "Maya Chen", "Jordan Rivers", "Sam Nova", "Riley Phoenix",
            "Casey Volt", "Quinn Shadow", "Avery Blaze", "Harper Frost", "Skyler Wave",
            "Dr. Marcus Vex", "Luna Darkmore", "Captain Steel", "Raven Nightshade", "Echo Prime",
            "Zara Lightning", "Kai Stormwind", "Nova Sterling", "Ash Blackthorne", "Vera Cosmos"
        ];

        const randomPowers_en = [ 
            "Super Strength", "Flight", "Telepathy", "Invisibility", "Elemental Manipulation",
            "Telekinesis", "Accelerated Healing", "Energy Blasts", "Time Control", "Shapeshifting",
            "X-Ray Vision", "Underwater Breathing", "Energy Absorption", "Shield Generation", "Super Speed",
            "Illusion", "Shadow Manipulation", "Mind Control", "Elasticity", "Force Field Generation"
        ];

        const randomReasons_en = [
            "saved their life in battle", "discovered their secret identity", "taught them a special technique",
            "protected their family", "revealed important information to them", "fought alongside them",
            "helped them through a difficult time", "shared a secret", "trained together",
            "saved them from a trap", "trusts my judgment", "gave them crucial advice",
            "helped them control their powers", "protected them from enemies", "showed them the right path"
        ];

        const randomInfluenceGains_en = [
            "saved my life", "discovered my weakness", "defeated me in combat",
            "taught me an important lesson", "helped me when I needed it most", "trust their expertise",
            "inspired me to be better", "protected me from great danger", "showed me my mistake",
            "earned my respect in battle", "helped me with my powers", "gave me hope",
            "defended me to others", "sacrificed something for me", "taught me about heroism"
        ];

        // Random data generators (Spanish)
        const randomNames_es = [
            "Alex Tormenta", "Maya Chen", "Jordan R√≠os", "Sam Nova", "Riley F√©nix",
            "Casey Voltio", "Quinn Sombra", "Avery Fuego", "Harper Escarcha", "Skyler Ola",
            "Dr. Marcus Vex", "Luna Oscura", "Capit√°n Acero", "Cuervo Noche", "Eco Prime",
            "Zara Rel√°mpago", "Kai Viento", "Nova Sterling", "Ash Espino", "Vera Cosmos"
        ];

        const randomPowers_es = [ 
            "Super Fuerza", "Vuelo", "Telepat√≠a", "Invisibilidad", "Manipulaci√≥n Elemental",
            "Telequinesis", "Curaci√≥n Acelerada", "Explosiones de Energ√≠a", "Control del Tiempo", "Cambio de Forma",
            "Visi√≥n de Rayos X", "Respiraci√≥n Subacu√°tica", "Absorci√≥n de Energ√≠a", "Generaci√≥n de Escudos", "S√∫per Velocidad",
            "Ilusi√≥n", "Manipulaci√≥n de Sombras", "Control Mental", "Elasticidad", "Generaci√≥n de Campos de Fuerza"
        ];

        const randomReasons_es = [
            "salv√© su vida en batalla", "descubr√≠ su identidad secreta", "le ense√±√© una t√©cnica especial",
            "proteg√≠ a su familia", "le revel√© informaci√≥n importante", "luch√© junto a √©l/ella",
            "le ayud√© en un momento dif√≠cil", "compartimos un secreto", "entren√© juntos",
            "le salv√© de una trampa", "conf√≠a en mi juicio", "le di consejos cruciales",
            "le ayud√≥ a controlar sus poderes", "le proteg√≠ de sus enemigos", "le mostr√≥ el camino correcto"
        ];

        const randomInfluenceGains_es = [
            "me salv√≥ la vida", "descubri√≥ mi punto d√©bil", "me derrot√≥ en combate",
            "me ense√±√≥ una lecci√≥n importante", "me ayud√≥ cuando m√°s lo necesitaba", "conf√≠o en su experiencia",
            "me inspir√≥ a ser mejor", "me protegi√≥ de un gran peligro", "me mostr√≥ mi error",
            "gan√≥ mi respeto en batalla", "me ayud√≥ con mis poderes", "me dio esperanza",
            "me defendi√≥ ante otros", "sacrific√≥ algo por m√≠", "me ense√±√≥ sobre el hero√≠smo"
        ];


        // Function to set the language
        function setLanguage(lang) {
            currentLang = lang;
            document.documentElement.lang = lang; // Set HTML lang attribute
            localStorage.setItem('masksInfluenceTracker_lang', lang); // Save preference

            // Update all elements with data-key attribute
            document.querySelectorAll('[data-key]').forEach(element => {
                const key = element.dataset.key;
                if (translations[lang][key]) {
                    if (element.tagName === 'INPUT' && element.type === 'file') {
                        // Do nothing for file input, as its text is browser-controlled
                    } else if (element.tagName === 'BUTTON' && (key === 'deleteBtn' || key === 'restoreBtn')) {
                        // Handled dynamically in createRow/deleteRow/undoDelete
                    } else {
                        element.textContent = translations[lang][key];
                    }
                }
            });

            // Special handling for editable headers
            loadHeaders(); 
            // Re-populate tables to ensure action button text is updated
            populateTablesFromData(); 

            // Update active language button styling
            document.querySelectorAll('.lang-btn').forEach(btn => {
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // Save data to localStorage
        function saveGameData() {
            localStorage.setItem('masksInfluenceTracker', JSON.stringify(gameData));
            localStorage.setItem('masksInfluenceTracker_sortState', JSON.stringify(sortState));
        }

        // Load data from localStorage
        function loadGameData() {
            const savedData = localStorage.getItem('masksInfluenceTracker');
            const savedSortState = localStorage.getItem('masksInfluenceTracker_sortState');
            if (savedData) {
                gameData = JSON.parse(savedData);
                if (savedSortState) {
                    sortState = JSON.parse(savedSortState);
                }
                return true;
            }
            return false;
        }

        // Save header text to localStorage
        function updateHeader(element, headerKey) {
            localStorage.setItem(`masksInfluenceTracker_header_${headerKey}`, element.textContent);
        }

        // Load header text from localStorage
        function loadHeaders() {
            const givePowerHeader = localStorage.getItem('masksInfluenceTracker_header_givePower');
            const receivePowerHeader = localStorage.getItem('masksInfluenceTracker_header_receivePower');

            if (givePowerHeader) {
                document.getElementById('givePowerHeader').textContent = givePowerHeader;
            } else {
                document.getElementById('givePowerHeader').textContent = translations[currentLang].powerHeader;
            }

            if (receivePowerHeader) {
                document.getElementById('receivePowerHeader').textContent = receivePowerHeader;
            } else {
                document.getElementById('receivePowerHeader').textContent = translations[currentLang].powerHeader;
            }
        }

        // Clear all data
        function clearAllData(event) { 
            // Using a custom confirmation message in the UI instead of window.confirm
            const confirmClear = confirm(translations[currentLang].confirmClear);
            if (confirmClear) {
                localStorage.removeItem('masksInfluenceTracker');
                localStorage.removeItem('masksInfluenceTracker_header_givePower'); 
                localStorage.removeItem('masksInfluenceTracker_header_receivePower'); 
                localStorage.removeItem('masksInfluenceTracker_sortState'); 
                gameData = { giveTable: [], receiveTable: [] };
                sortState = { giveTable: { column: null, direction: 'asc' }, receiveTable: { column: null, direction: 'asc' } };
                populateTablesFromData();
                loadHeaders(); 
                updateSortIcons(); 
                
                // Visual feedback
                const button = event.target;
                const originalText = button.textContent;
                const originalClass = button.className;
                
                button.textContent = translations[currentLang].clearedMsg;
                button.className = 'lookup-btn clear-btn';
                button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.className = originalClass;
                    button.style.background = '';
                }, 1500);
            }
        }

        // Populate tables from gameData, filtering out deleted rows
        function populateTablesFromData() {
            // Clear existing tables
            document.getElementById('giveTable').querySelector('tbody').innerHTML = '';
            document.getElementById('receiveTable').querySelector('tbody').innerHTML = '';

            // Populate giveTable
            const giveTableBody = document.getElementById('giveTable').querySelector('tbody');
            const sortedGiveData = sortTableData('giveTable', gameData.giveTable);
            sortedGiveData.forEach(rowData => {
                // Only render if not deleted OR if it's a temporary blank row (for printing)
                if (!rowData.deleted || rowData.tempBlank) {
                    const row = createRow(
                        rowData.name,
                        rowData.power, 
                        rowData.reason,
                        rowData.date,
                        rowData.checked,
                        rowData.deleted, 
                        'giveTable',
                        rowData.tempBlank
                    );
                    giveTableBody.appendChild(row);
                }
            });

            // Populate receiveTable
            const receiveTableBody = document.getElementById('receiveTable').querySelector('tbody');
            const sortedReceiveData = sortTableData('receiveTable', gameData.receiveTable);
            sortedReceiveData.forEach(rowData => {
                // Only render if not deleted OR if it's a temporary blank row (for printing)
                if (!rowData.deleted || rowData.tempBlank) {
                    const row = createRow(
                        rowData.name,
                        rowData.power, 
                        rowData.reason,
                        rowData.date,
                        rowData.checked,
                        rowData.deleted, 
                        'receiveTable',
                        rowData.tempBlank
                    );
                    receiveTableBody.appendChild(row);
                }
            });
            updateSortIcons();
        }
        
        // This function now adds "data" for blank rows into gameData temporarily
        function addBlankRowsForPrinting() {
            const targetRows = 15; // Approximately 15 rows fit on A4 landscape
            
            // Add blank data rows to give table
            const currentGiveDataRows = gameData.giveTable.filter(row => !row.deleted).length;
            for (let i = currentGiveDataRows; i < targetRows; i++) {
                gameData.giveTable.push({
                    checked: false, name: "", power: "", reason: "", date: "", deleted: false, tempBlank: true 
                });
            }
            
            // Add blank data rows to receive table
            const currentReceiveDataRows = gameData.receiveTable.filter(row => !row.deleted).length;
            for (let i = currentReceiveDataRows; i < targetRows; i++) {
                gameData.receiveTable.push({
                    checked: false, name: "", power: "", reason: "", date: "", deleted: false, tempBlank: true 
                });
            }
        }

        function prepareForPrinting() {
            // Store the current state of gameData
            originalGameData = JSON.parse(JSON.stringify(gameData)); 

            addBlankRowsForPrinting(); // Add blank rows to gameData
            populateTablesFromData(); // Re-render tables with blank rows

            window.print();
            
            // Revert gameData and re-populate after printing is done (or canceled)
            // Use setTimeout to allow the print dialog to be handled first
            setTimeout(() => {
                gameData = JSON.parse(JSON.stringify(originalGameData)); // Restore original data
                populateTablesFromData(); // Re-render tables without blank rows
            }, 500); // Give a little time for print dialog to appear/close
        }

        function generateRandomData() {
            const shuffleArray = (array) => {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            };

            const getRandomDate = () => {
                const months = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", 
                               "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
                const month = months[Math.floor(Math.random() * months.length)];
                const day = Math.floor(Math.random() * 28) + 1;
                return `${day} ${month}`;
            };

            // Select random data lists based on current language
            const namesList = currentLang === 'en' ? randomNames_en : randomNames_es;
            const powersList = currentLang === 'en' ? randomPowers_en : randomPowers_es;
            const reasonsList = currentLang === 'en' ? randomReasons_en : randomReasons_es;
            const influenceGainsList = currentLang === 'en' ? randomInfluenceGains_en : randomInfluenceGains_es;


            const numEntries = Math.floor(Math.random() * 6) + 4; // 4-9 entries
            const shuffledNames = shuffleArray(namesList);
            const shuffledPowers = shuffleArray(powersList); 

            const giveTable = [];
            const receiveTable = [];

            for (let i = 0; i < numEntries && i < shuffledNames.length; i++) {
                const name = shuffledNames[i];
                const power = shuffledPowers[i]; 
                const date = getRandomDate();

                // Some entries appear in both tables, some only in one
                const inBoth = Math.random() < 0.6; // 60% chance to be in both
                const inGive = inBoth || Math.random() < 0.7; // 70% chance if not in both
                const inReceive = inBoth || !inGive || Math.random() < 0.7;

                if (inGive) {
                    const reason = reasonsList[Math.floor(Math.random() * reasonsList.length)];
                    giveTable.push({
                        checked: false,
                        name: name,
                        power: power, 
                        reason: reason,
                        date: date,
                        deleted: false,
                        tempBlank: false
                    });
                }

                if (inReceive) {
                    const howGained = influenceGainsList[Math.floor(Math.random() * influenceGainsList.length)];
                    receiveTable.push({
                        checked: false,
                        name: name,
                        power: power, 
                        reason: howGained,
                        date: date,
                        deleted: false,
                        tempBlank: false
                    });
                }
            }

            return { giveTable, receiveTable };
        }

        function loadPreset(event, preset) { 
            let data;
            
            if (preset === 'random') {
                data = generateRandomData();
            } else {
                data = defaultDataSets[preset];
            }

            // Update gameData
            gameData = {
                giveTable: [...data.giveTable],
                receiveTable: [...data.receiveTable]
            };
            
            // Save and populate tables
            saveGameData();
            populateTablesFromData();

            // Visual feedback only if a valid event object is provided (i.e., not called from DOMContentLoaded)
            if (event && event.target) {
                const button = event.target;
                const originalText = button.textContent;
                const originalClass = button.className;
                
                button.textContent = translations[currentLang].loadedMsg;
                button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.className = originalClass;
                    button.style.background = '';
                }, 1500);
            }
        }

        function createRow(name = "", power = "", reason = "", date = "", checked = false, deleted = false, tableId = "", tempBlank = false) { 
            const tr = document.createElement("tr");
            if (deleted) {
                tr.classList.add("deleted"); // Apply deleted style if marked
            }
            if (tempBlank) {
                tr.classList.add("blank-row"); // Apply blank row style for printing
            }
            
            tr.innerHTML = `
                <td class="checkbox-cell">
                    ${tempBlank ? `<input type="checkbox" disabled>` : `<input type="checkbox" ${checked ? "checked" : ""} onchange="updateRowData(this)">`}
                </td>
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${name || '&nbsp;'}</td>
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${power || '&nbsp;'}</td> 
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${reason || '&nbsp;'}</td>
                <td contenteditable="${!tempBlank}" oninput="updateRowData(this)">${date || '&nbsp;'}</td>
                <td class="actions-cell no-print">
                    ${tempBlank ? '&nbsp;' : 
                        (deleted ? 
                            `<button class="action-btn undo-btn" onclick="undoDelete(this)">${translations[currentLang].restoreBtn}</button>` :
                            `<button class="action-btn delete-btn" onclick="deleteRow(this)">${translations[currentLang].deleteBtn}</button>`
                        )
                    }
                </td>
            `;
            
            return tr;
        }

        function addRow(tableId) {
            const newRowData = {
                checked: false,
                name: "",
                power: "", 
                reason: "",
                date: "",
                deleted: false,
                tempBlank: false // New rows are not temporary blank
            };
            gameData[tableId].push(newRowData);
            saveGameData();
            populateTablesFromData(); // Re-populate to show the new row

            // Find the newly added row in the DOM and focus on its first editable cell
            const tableBody = document.getElementById(tableId).querySelector('tbody');
            const lastRow = tableBody.lastElementChild;
            if (lastRow) {
                const firstEditableCell = lastRow.querySelector('td[contenteditable="true"]');
                if (firstEditableCell) {
                    firstEditableCell.focus();
                }
            }
        }

        function deleteRow(button) {
            const row = button.closest('tr');
            const table = button.closest('table');
            const tableId = table.id;
            const rowIndexInDOM = Array.from(table.querySelectorAll('tbody tr')).indexOf(row);
            
            // Find the corresponding data item in gameData (considering visible rows only for indexing)
            let dataIndex = -1;
            let visibleCount = 0;
            const currentTableData = sortTableData(tableId, gameData[tableId]); // Get currently sorted data
            for (let i = 0; i < currentTableData.length; i++) {
                // If the row is not deleted and not a temporary blank row, it's visible in normal view
                if (!currentTableData[i].deleted && !currentTableData[i].tempBlank) {
                    if (visibleCount === rowIndexInDOM) {
                        // Find the original index in gameData
                        dataIndex = gameData[tableId].findIndex(item => 
                            item.name === currentTableData[i].name && 
                            item.power === currentTableData[i].power && 
                            item.reason === currentTableData[i].reason &&
                            item.date === currentTableData[i].date &&
                            item.checked === currentTableData[i].checked &&
                            item.deleted === currentTableData[i].deleted &&
                            item.tempBlank === currentTableData[i].tempBlank
                        );
                        break;
                    }
                    visibleCount++;
                }
            }

            if (dataIndex !== -1) {
                gameData[tableId][dataIndex].deleted = true; // Mark as deleted in gameData
                saveGameData(); // Save the updated data

                // Immediately update UI to show it's marked for deletion, but don't remove
                row.classList.add('deleted');
                button.textContent = translations[currentLang].restoreBtn;
                button.className = 'action-btn undo-btn';
                // Update the onclick to point to undoDelete
                button.onclick = () => undoDelete(button); 
            }
        }

        function undoDelete(button) {
            const row = button.closest('tr');
            const table = button.closest('table');
            const tableId = table.id;
            // The name and power are used to find the corresponding data item in gameData
            const nameToFind = row.querySelector('td:nth-child(2)').textContent; 
            const powerToFind = row.querySelector('td:nth-child(3)').textContent; 
            
            // Find the row in gameData that matches the name, power, and is currently marked as deleted
            const dataRowIndex = gameData[tableId].findIndex(item => 
                item.name === nameToFind && item.power === powerToFind && item.deleted 
            );
            
            if (dataRowIndex !== -1) {
                gameData[tableId][dataRowIndex].deleted = false; // Mark as not deleted
                saveGameData(); // Save updated data
                
                // Immediately update UI to show it's restored
                row.classList.remove('deleted');
                button.textContent = translations[currentLang].deleteBtn;
                button.className = 'action-btn delete-btn';
                // Update the onclick to point back to deleteRow
                button.onclick = () => deleteRow(button);
            }
        }

        function updateRowData(element) {
            const row = element.closest('tr');
            const table = element.closest('table');
            const tableId = table.id;
            const rowIndexInDOM = Array.from(table.querySelectorAll('tbody tr')).indexOf(row);
            
            // Find the corresponding data item in gameData based on its current visible position
            let dataIndex = -1;
            let visibleCount = 0;
            const currentTableData = sortTableData(tableId, gameData[tableId]); // Get currently sorted data
            for (let i = 0; i < currentTableData.length; i++) {
                // Only consider non-deleted and non-temporary blank rows for visible indexing
                if (!currentTableData[i].deleted && !currentTableData[i].tempBlank) {
                    if (visibleCount === rowIndexInDOM) {
                        // Find the original index in gameData
                        dataIndex = gameData[tableId].findIndex(item => 
                            item.name === currentTableData[i].name && 
                            item.power === currentTableData[i].power && 
                            item.reason === currentTableData[i].reason &&
                            item.date === currentTableData[i].date &&
                            item.checked === currentTableData[i].checked &&
                            item.deleted === currentTableData[i].deleted &&
                            item.tempBlank === currentTableData[i].tempBlank
                        );
                        break;
                    }
                    visibleCount++;
                }
            }
            
            if (dataIndex !== -1 && gameData[tableId][dataIndex]) {
                const cells = row.querySelectorAll('td');
                const checkbox = cells[0].querySelector('input[type="checkbox"]');
                
                gameData[tableId][dataIndex] = {
                    ...gameData[tableId][dataIndex], // Keep existing properties like 'deleted', 'tempBlank'
                    checked: checkbox ? checkbox.checked : false,
                    name: cells[1].textContent,
                    power: cells[2].textContent, 
                    reason: cells[3].textContent,
                    date: cells[4].textContent
                };
                
                saveGameData(); // Save data
            }
        }

        /**
         * Exports the current game data and header information to a JSON file,
         * triggering a download for the user.
         * @param {Event} event The click event from the button.
         */
        function exportDataToJson(event) {
            const dataToSave = {
                gameData: gameData,
                headers: {
                    givePower: document.getElementById('givePowerHeader').textContent, 
                    receivePower: document.getElementById('receivePowerHeader').textContent 
                }
            };
            const jsonData = JSON.stringify(dataToSave, null, 2); // Pretty print JSON for readability
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'masks_influence_tracker_data.json'; // Default filename
            document.body.appendChild(a);
            a.click(); // Programmatically click the link to trigger download
            document.body.removeChild(a); // Clean up the temporary link
            URL.revokeObjectURL(url); // Release the object URL

            // Visual feedback for the button
            const button = event.target;
            const originalText = button.textContent;
            const originalClass = button.className;
            
            button.textContent = translations[currentLang].downloadedMsg;
            button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)'; // Green for success
            
            setTimeout(() => {
                button.textContent = originalText;
                button.className = originalClass;
                button.style.background = ''; // Revert background
            }, 1500); // Revert after 1.5 seconds
        }

        /**
         * Imports game data and header information from a selected JSON file.
         * @param {Event} event The change event from the file input.
         */
        function importDataFromJson(event) {
            const file = event.target.files[0];
            const button = document.querySelector('.import-btn'); // Get the import button for feedback
            const originalText = button.textContent;
            const originalClass = button.className;

            if (!file) {
                // No file selected, reset button feedback if it was previously showing an error
                button.textContent = originalText;
                button.className = originalClass;
                button.style.background = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    // Validate the structure of the imported data
                    if (importedData.gameData && importedData.headers && 
                        importedData.gameData.giveTable && importedData.gameData.receiveTable &&
                        importedData.headers.givePower !== undefined && importedData.headers.receivePower !== undefined) { 
                        
                        gameData = importedData.gameData; // Update global gameData
                        
                        // Restore headers to localStorage
                        localStorage.setItem('masksInfluenceTracker_header_givePower', importedData.headers.givePower); 
                        localStorage.setItem('masksInfluenceTracker_header_receivePower', importedData.headers.receivePower); 
                        
                        saveGameData(); // Save the newly imported data to localStorage
                        populateTablesFromData(); // Refresh tables with new data
                        loadHeaders(); // Refresh headers with new data

                        // Visual feedback for success
                        button.textContent = translations[currentLang].loadedMsg;
                        button.style.background = 'linear-gradient(45deg, #2ed573, #1dd361)'; // Green for success
                        
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.className = originalClass;
                            button.style.background = '';
                        }, 1500);

                    } else {
                        // Invalid file format
                        console.error("Error: El archivo JSON no tiene el formato esperado.");
                        button.textContent = translations[currentLang].errorMsg;
                        button.style.background = 'linear-gradient(45deg, #ff4757, #ff3742)'; // Red for error
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.className = originalClass;
                            button.style.background = '';
                        }, 2500);
                    }
                } catch (error) {
                    // JSON parsing error
                    console.error("Error al leer el archivo JSON: ", error);
                    button.textContent = translations[currentLang].jsonErrorMsg;
                    button.style.background = 'linear-gradient(45deg, #ff4757, #ff3742)'; // Red for error
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.className = originalClass;
                        button.style.background = '';
                    }, 2500);
                }
            };
            reader.readAsText(file); // Read the file content as text
            // Clear the input so the same file can be re-selected if needed
            event.target.value = '';
        }

        // Sort function for table data
        function sortTableData(tableId, data) {
            const { column, direction } = sortState[tableId];
            if (!column) {
                return data; // No column to sort, return original data
            }

            // Create a copy to avoid modifying the original array during sort
            const sortedData = [...data];

            sortedData.sort((a, b) => {
                const aValue = a[column] ? String(a[column]).toLowerCase() : '';
                const bValue = b[column] ? String(b[column]).toLowerCase() : '';

                if (aValue < bValue) {
                    return direction === 'asc' ? -1 : 1;
                }
                if (aValue > bValue) {
                    return direction === 'asc' ? 1 : -1;
                }
                return 0;
            });
            return sortedData;
        }

        // Handle header click for sorting
        function handleSortClick(event) {
            const header = event.currentTarget;
            const table = header.closest('table');
            const tableId = table.id;
            const column = header.dataset.column;

            if (sortState[tableId].column === column) {
                // If same column, toggle direction
                sortState[tableId].direction = sortState[tableId].direction === 'asc' ? 'desc' : 'asc';
            } else {
                // If new column, set to asc
                sortState[tableId].column = column;
                sortState[tableId].direction = 'asc';
            }
            saveGameData(); // Save updated sort state
            populateTablesFromData(); // Re-populate tables with sorted data
        }

        // Update sort icons in headers
        function updateSortIcons() {
            document.querySelectorAll('.sortable').forEach(header => {
                const tableId = header.closest('table').id;
                const column = header.dataset.column;
                const icon = header.querySelector('.sort-icon');

                header.classList.remove('asc', 'desc');
                if (sortState[tableId].column === column) {
                    header.classList.add(sortState[tableId].direction);
                }
            });
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            // Set initial language based on localStorage or default
            setLanguage(currentLang);

            // Try to load saved data first
            if (!loadGameData()) {
                // If no saved data, load the random preset
                loadPreset(null, 'random'); 
            } else {
                // If loaded saved data, populate tables
                populateTablesFromData();
            }

            // Load saved headers (will use currentLang for default if not saved)
            loadHeaders();

            // Add event listeners for sortable headers
            document.querySelectorAll('.sortable').forEach(header => {
                header.addEventListener('click', handleSortClick);
            });

            // Add event listeners for language toggle buttons
            document.querySelectorAll('.lang-btn').forEach(button => {
                button.addEventListener('click', (event) => {
                    setLanguage(event.target.dataset.lang);
                });
            });

            // Update print button
            const printBtn = document.querySelector('.print-btn');
            if (printBtn) {
                printBtn.onclick = prepareForPrinting;
            }
        });
    </script>
</body>
</html>
